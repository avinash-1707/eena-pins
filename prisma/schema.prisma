generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  USER
  BRAND
  ADMIN
}

enum BrandRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model Account {
  id                String   @id @default(uuid())
  userId            String
  provider          String
  providerAccountId String
  type              String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model User {
  id String @id @default(uuid())

  // Auth identifiers
  email String? @unique
  phone String? @unique

  // Email verification
  emailVerificationToken        String?   @unique
  emailVerificationTokenExpiresAt DateTime?

  // Profile
  username    String  @unique
  name        String?
  description String
  avatarUrl   String?

  role Role @default(USER)

  createdAt DateTime @default(now())

  // Relations
  accounts Account[]

  // Customer
  orders    Order[]
  addresses Address[]

  // Brand access
  brandProfile   BrandProfile?
  brandRequest   BrandRequest?

  // Social
  ratings     UserRating[]
  collections Collection[]
}

model BrandProfile {
  id     String @id @default(uuid())
  userId String @unique

  brandName   String
  logoUrl     String?
  description String?

  // Compliance
  gstNumber    String?
  panNumber    String?
  businessType String?

  // Razorpay
  bankAccountNo       String?
  ifscCode            String?
  razorpayContactId   String?
  razorpayFundAccount String?

  isApproved    Boolean @default(false)
  payoutEnabled Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  products   Product[]
  orderItems OrderItem[]
}

model BrandRequest {
  id        String             @id @default(uuid())
  userId    String             @unique
  status    BrandRequestStatus  @default(PENDING)
  message   String?
  createdAt DateTime           @default(now())
  reviewedAt DateTime?
  reviewedById String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Address {
  id String @id @default(uuid())

  userId String
  
  // Address details
  fullName    String
  phone       String
  street      String
  city        String
  state       String
  pincode     String
  label       String? // "Home", "Work", etc.
  isDefault   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  shippingOrders Order[] @relation("ShippingAddress")
  billingOrders  Order[] @relation("BillingAddress")

  @@index([userId])
}

model PhoneOTP {
  id        String   @id @default(uuid())
  phone     String
  otpHash   String
  expiresAt DateTime
  used      Boolean  @default(false)
  attempts  Int      @default(0)

  @@index([phone])
}

model Product {
  id              String  @id @default(uuid())
  name            String
  price           Int     @default(0)
  imageUrl        String
  category        String
  description     String
  warrantyMonths  Int?
  freeShippingOn  Boolean @default(false)
  returnAvailable Boolean @default(false)

  // Brand ownership
  brandProfileId String
  brandProfile   BrandProfile @relation(fields: [brandProfileId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  details     ProductDetail?
  ratings     UserRating[]
  collections CollectionProduct[]
  orderItems  OrderItem[]

  @@index([brandProfileId])
}

model ProductDetail {
  id        String @id @default(uuid())
  productId String @unique

  brand       String?
  material    String?
  keyFeatures String[] // array of strings
  moreOptions Json? // key-value pairs
  rating      Float?

  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model UserRating {
  id        String  @id @default(uuid())
  userId    String
  productId String
  rating    Int
  review    String?

  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([userId, productId]) // one rating per user per product
}

model Collection {
  id       String  @id @default(uuid())
  name     String
  isPublic Boolean @default(true)

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  products CollectionProduct[]

  @@unique([userId, name]) // user can't create same collection twice
}

model CollectionProduct {
  id           String @id @default(uuid())
  collectionId String
  productId    String

  createdAt DateTime @default(now())

  collection Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  product    Product    @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([collectionId, productId]) // no duplicate bookmarks
}

enum OrderStatus {
  CREATED
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentStatus {
  CREATED
  AUTHORIZED
  CAPTURED
  FAILED
  REFUNDED
}

model Order {
  id     String      @id @default(uuid())
  userId String
  status OrderStatus @default(CREATED)

  totalAmount Int // total paid by customer (â‚¹ in paise)
  platformFee Int // commission amount
  currency    String @default("INR")

  razorpayOrderId String? @unique
  receipt         String? // your internal receipt/order no

  // Shipping and Billing Addresses
  shippingAddressId String?
  billingAddressId  String?

  deliveredAt       DateTime? // set when status -> DELIVERED
  returnWindowEndsAt DateTime? // deliveredAt + N days for payout eligibility

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user              User         @relation(fields: [userId], references: [id])
  shippingAddress   Address?     @relation("ShippingAddress", fields: [shippingAddressId], references: [id], onDelete: SetNull)
  billingAddress    Address?     @relation("BillingAddress", fields: [billingAddressId], references: [id], onDelete: SetNull)
  items             OrderItem[]
  payment           Payment?

  @@index([userId])
  @@index([shippingAddressId])
  @@index([billingAddressId])
}

model OrderItem {
  id String @id @default(uuid())

  orderId        String
  productId      String
  brandProfileId String

  quantity    Int @default(1)
  price       Int // product price * quantity
  commission  Int // platform commission for this item
  brandAmount Int // price - commission

  order        Order        @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product      Product      @relation(fields: [productId], references: [id])
  brandProfile BrandProfile @relation(fields: [brandProfileId], references: [id])

  @@index([orderId])
  @@index([brandProfileId])
}

model Payment {
  id String @id @default(uuid())

  orderId String        @unique
  status  PaymentStatus @default(CREATED)

  razorpayPaymentId String? @unique
  razorpaySignature String?

  method   String? // card / upi / wallet
  amount   Int
  currency String  @default("INR")

  paidAt DateTime?

  refundedAt       DateTime?
  razorpayRefundId String?

  createdAt DateTime @default(now())

  order Order @relation(fields: [orderId], references: [id])
}